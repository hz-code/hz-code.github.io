<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>async函数学习记录</title>
      <link href="2021/02/27/async%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>2021/02/27/async%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一-Generator函数"><a href="#一-Generator函数" class="headerlink" title="一. Generator函数"></a><strong>一. Generator函数</strong></h2><p>Generator函数从语法上可以理解成一个状态机，它的内部封装了多个状态。当执行Generator函数时候会返回一个遍历器对象，返回的遍历器对象可以一次遍历Generator函数内部的每一个状态。</p><p>形式上，Generator函数只是一个普通函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">testGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;I am&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Generator&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = testGenerator();</span><br></pre></td></tr></table></figure><p>它有两个特征，一是，function关键字与函数名之间有一个<code>*</code>号；二是，函数体内部使用<code>yield</code>表达式定义不同的内部状态。上述代码定义了一个Generator函数<code>testGenerator</code>，在它的内部有两个<code>yield</code>表达式，同时该函数有三个状态：I am，Generator和return语句。</p><p>调用Generator函数后，该函数不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象（也就是遍历器对象）。</p><p>调用Generator函数的下一步是必须调用遍历器的<code>next</code>发明方法，使得指针移向下一个状态。每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式或<code>return</code>语句。简单概括，Generator函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，<code>next</code>方法可以恢复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;I am&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">test.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;Generator&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">test.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">test.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上述代码一共调用了四次next()方法。</p><p><font color="orange">注：<code>yield</code>只能用在Generator函数中；<code>yield</code>表达式如果用在另一个表达式之中，必须放在圆括号内</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="orange"><code>yield</code>表达式用作函数参数或放在赋值表达式右边，可以不加括号</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo(<span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>, <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="keyword">yield</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="orange"><code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值</font></p><h3 id="1-1-Generator-prototype-throw"><a href="#1-1-Generator-prototype-throw" class="headerlink" title="1.1 Generator.prototype.throw()"></a><strong>1.1 Generator.prototype.throw()</strong></h3><p>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  i.throw(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure><p><font color="orange">不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。<code>throw</code>命令抛出的错误只能被函数体外的<code>catch</code>语句捕获。</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="string">&#x27;a&#x27;</span>) <span class="keyword">throw</span> e;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 [Error: a]</span></span><br></pre></td></tr></table></figure><p><font color="orange">如果Generator函数内部没用部署<code>try...catch</code>代码块，<code>throw</code>方法抛出的错误，将被外部<code>try...catch</code>代码块捕获</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  i.throw(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 a</span></span><br></pre></td></tr></table></figure><h3 id="1-2-Generator-prototype-return"><a href="#1-2-Generator-prototype-return" class="headerlink" title="1.2 Generator.prototype.return()"></a><strong>1.2 Generator.prototype.return()</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next()        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line">g.next()        <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>g</code>调用<code>return()</code>方法后，返回值的<code>value</code>属性就是<code>return()</code>方法的参数<code>foo</code>。并且，Generator 函数的遍历就终止了，返回值的<code>done</code>属性为<code>true</code>，以后再调用<code>next()</code>方法，<code>done</code>属性总是返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next()        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>如果<code>return()</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = numbers();</span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.return(<span class="number">7</span>) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>如果 Generator 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return()</code>方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束。</p><p>上面代码中，调用<code>return()</code>方法后，就开始执行<code>finally</code>代码块，不执行<code>try</code>里面剩下的代码了，然后等到<code>finally</code>代码块执行完，再返回<code>return()</code>方法指定的返回值。</p><h2 id="二-async函数"><a href="#二-async函数" class="headerlink" title="二. async函数"></a><strong>二. async函数</strong></h2><p><code>async</code>函数使得异步操作变得更加方便。简单概括async函数，它就说Generator函数的语法糖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/test1&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/test2&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/test1&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/test2&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过比较发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p><p>（1）内置执行器。</p><p>Generator 函数的执行必须靠执行器，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure><p>上面的代码调用了<code>test</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，才能真正执行，得到最后结果。</p><p>（2）更好的语义。</p><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p><p>（3）更广的适用性。</p><p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p><p>（4）返回值是 Promise。</p><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p><p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><h2 id="三-async函数的实现原理"><a href="#三-async函数的实现原理" class="headerlink" title="三. async函数的实现原理"></a><strong>三. async函数的实现原理</strong></h2><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p><p><code>spawn</code>函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> gen = genF();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = nextF();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(v); &#125;);</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重绘和回流</title>
      <link href="2021/02/26/%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/"/>
      <url>2021/02/26/%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="一-重绘和回流的概念"><a href="#一-重绘和回流的概念" class="headerlink" title="一. 重绘和回流的概念"></a><strong>一. 重绘和回流的概念</strong></h2><p>&emsp;&emsp;重绘（repaint）：从名字来看，重绘 = 重新绘制（绘画 + 上色） 。当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性<code>绘制一遍</code>，将内容呈现在页面上。而重绘是指一个元素<code>外观改变</code>所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p><p>&emsp;&emsp;<font color="orange">触发重绘的条件：元的外观属性改变，如:  color，background-color等。</font></p><p>&emsp;&emsp;回流（重排/重构/reflow）：取其中最容易理解的重构来说，重构 = 重新构建。当渲染树中的一部分（或全部）因为元素的<code>规模尺寸、布局、隐藏</code>等属性改变而需要重新构建的时候，这就称为回流。</p><p>&emsp;&emsp;<font color="orange">每个页面至少需要一次回流，那就是在页面第一次加载的时候</font></p><p>&emsp;&emsp;<font color="orange">触发回流的条件:<br/>&emsp;&emsp;1、页面渲染初始化（无法避免）；<br/>&emsp;&emsp;2、添加或删除可见的DOM元素；<br/>&emsp;&emsp;3、元素位置的改变，或者使用动画；<br/>&emsp;&emsp;4、元素尺寸的改变——大小，外边距，边框；<br/>&emsp;&emsp;5、浏览器窗口尺寸的变化（resize事件发生时）；<br/>&emsp;&emsp;6、填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；<br/>&emsp;&emsp;7、读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)</font></p><h2 id="二-重绘和回流的关系"><a href="#二-重绘和回流的关系" class="headerlink" title="二. 重绘和回流的关系"></a><strong>二. 重绘和回流的关系</strong></h2><p>&emsp;&emsp;在回流的时候，浏览器会使渲染树中收到影响的部分失效，并重新构建这部分渲染树。完成回流后，浏览器会重新绘制所受影响的部分到页面中，该过程称为重绘。<font color="orange">所以，回流必定引发重绘，但是重绘不一定会引发回流</font>。</p><center><font color="red"><b>重绘回流的代价：耗时，导致浏览器卡慢!!!</b></font></center><h2 id="三-重绘回流操作的优化方案"><a href="#三-重绘回流操作的优化方案" class="headerlink" title="三. 重绘回流操作的优化方案"></a><strong>三. 重绘回流操作的优化方案</strong></h2><h3 id="3-1-最小化重绘和回流"><a href="#3-1-最小化重绘和回流" class="headerlink" title="3.1 最小化重绘和回流"></a>3.1 最小化重绘和回流</h3><p>&emsp;&emsp;由于重绘和回流操作的代价昂贵，因此最直接的优化方法就说减少重绘和回流的发生次数。我们可以合并对此对DOM或样式的修改，然后进行一次处理。</p><p>&emsp;&emsp;例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;editStyle&#x27;</span>);</span><br><span class="line">el.style.padding = <span class="string">&#x27;5px&#x27;</span>;</span><br><span class="line">el.style.width = <span class="string">&#x27;10px&#x27;</span>;</span><br><span class="line">el.style.height = <span class="string">&#x27;20px&#x27;</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中，又多个样式属性被修改，这些属性都会影响元素的<code>几何结构变化</code>，所以它们都会引发<code>回流</code>，在旧版本浏览器中上述代码会引发三次回流。为了减少回流，我们可以采取合并修改的方式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;editStyle&#x27;</span>);</span><br><span class="line">el.style.cssText += <span class="string">&#x27;padding: 5px; width:10px; height:20px&#x27;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.edit</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;editStyle&#x27;</span>);</span><br><span class="line">el.className += <span class="string">&#x27;edit&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-通过display属性设置"><a href="#3-2-通过display属性设置" class="headerlink" title="3.2 通过display属性设置"></a><strong>3.2 通过display属性设置</strong></h3><p>&emsp;&emsp;在对元素样式进行修改的时候，我们可以先设置元素的<code>display</code>属性为<code>none</code>（这是因为隐藏元素进行操作的时候是不会引起重绘和回流的），然后进行页面布局或样式修改等操作。当这些操作完成后，再将元素<code>display</code>属性设置为<code>block</code>,通过修改display属性只引发两次重绘和回流。</p><h3 id="3-3-通过position属性设置"><a href="#3-3-通过position属性设置" class="headerlink" title="3.3 通过position属性设置"></a><strong>3.3 通过position属性设置</strong></h3><p>&emsp;&emsp;将需要多次回流的元素的<code>postion</code>属性设置<code>为absolute</code>或者<code>fixed</code>，这样会使元素脱离文档流，这时候它的变化不会影响到其它元素。</p><p>&emsp;&emsp;<font color="orange">注：脱离文档流指的是元素脱离正常元素的布局排版工会则，其他处于文档流中的元素再计算布局排版的时候，会自动无视已经脱离文档流的元素进行定位。</font></p><p>&emsp;&emsp;<font color="orange">浮动与absolute/fixed的区别就在于，浮动会使元素脱离文档流，但不会脱离文本流，在与其他元素的文本内容计算布局的时候，还是占位置的；absolute/fixed既脱离文档流也脱离文本流。</font></p><h3 id="3-4-cloneNode-和-replaceChild"><a href="#3-4-cloneNode-和-replaceChild" class="headerlink" title="3.4 cloneNode 和 replaceChild"></a><strong>3.4 cloneNode 和 replaceChild</strong></h3><p>&emsp;&emsp;通过使用cloneNode和replaceChild技术，只引发一次重绘和回流。</p><p>cloneNode使用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cloneNode创建一个test节点的拷贝</span></span><br><span class="line"><span class="comment">// cloneNode(true)时递归赋值test节点的所有子孙节点</span></span><br><span class="line"><span class="comment">// cloneNode(false)时只赋值当前节点</span></span><br><span class="line"><span class="keyword">var</span> node=<span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>).lastChild.cloneNode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略了对赋值节点属性的操作</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加赋值的node节点作为oldNode节点的子节点</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;oldNode&quot;</span>).appendChild(node);</span><br></pre></td></tr></table></figure><p>replaceChild使用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了对newNode节点属性的操作</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将test的子节点替换为一个新的节点</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>).replaceChild(newnode,oldnode);</span><br></pre></td></tr></table></figure><h3 id="3-5-createDocumentFragment"><a href="#3-5-createDocumentFragment" class="headerlink" title="3.5 createDocumentFragment"></a><strong>3.5 createDocumentFragment</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createDocumentFragment()方法创建了一个虚拟的节点对象，节点对象包含所有的属性和方法。</span></span><br><span class="line"><span class="keyword">var</span> d=<span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对创建的虚拟节点进行操作</span></span><br><span class="line"><span class="comment">// 如果使用appendChid方法将原dom树中的节点添加到DocumentFragment中时，会删除原来的节点。 </span></span><br><span class="line">d.appendChild(<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;LI&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">d.childNodes[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue=<span class="string">&quot;Milk&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当请求把一个DocumentFragment节点插入文档树时，插入的不是DocumentFragment自身，而是它的所有子孙节点，即插入的是括号里的节点。这个特性使得DocumentFragment成了占位符，暂时存放那些一次插入文档的节点。</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;UL&quot;</span>)[<span class="number">0</span>].appendChild(d);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端优化 </category>
          
          <category> html/css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端优化 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> html/css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解浏览器运行机制</title>
      <link href="2021/02/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>2021/02/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一-进程和线程"><a href="#一-进程和线程" class="headerlink" title="一. 进程和线程"></a>一. 进程和线程</h2><p>​        计算机的核心是CPU，它承担了所有的计算任务。我们假设CPU是一个时刻在运行的工厂，假设工厂的电力有限（CPU的计算能力有限），一次只能供给一个车间（单个CPU一次只能运行一个任务）。</p><p>​        进程就像工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，同时其他进程处于非运行状态;</p><p>​        而线程是工厂车间中的工人，可能只有一个，也可能有很多个，他们协同完成工作。车间的空间是工人们共享的，这意味着一个进程下的线程共享该进程的内存空间。</p><hr><p><font color="red">注:<br>&emsp;&emsp;一个软件不等于一个进程，一个软件可能包含有多个户向独立的进程；<br/><br>&emsp;&emsp;进程是系统资源分配的最小单位(即系统以进程为最小单位分配内存空间，同时进程是能独立运行的最小单位）；<br/><br>&emsp;&emsp;线程是系统调度的最小单位（即系统以进程为单位分配CPUT中的核）；<br/><br>&emsp;&emsp;进程之间也能相互通信，但代价较大。</font></p><h2 id="二-浏览器中的进程"><a href="#二-浏览器中的进程" class="headerlink" title="二. 浏览器中的进程"></a>二. 浏览器中的进程</h2><p><img src="/img/1.png" class="lazyload" data-srcset="/img/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="2-1-浏览器主进程（Browser进程）"><a href="#2-1-浏览器主进程（Browser进程）" class="headerlink" title="2.1 浏览器主进程（Browser进程）"></a><strong>2.1 浏览器主进程（Browser进程）</strong></h3><p>&emsp;&emsp;浏览器的主进程只有一个，负责协调、主控。</p><ul><li>&emsp;负责浏览器界面显示，与用户交互，如前进，后退等；</li><li>&emsp;负责各个页面的管理，创建和销毁其他进程；</li><li>&emsp;负责将渲染进程得到的内存中的 Bitmap，绘制到用户界面上；</li><li>&emsp;负责网络资源的管理，下载等。</li></ul><h3 id="2-2-第三方插件进程"><a href="#2-2-第三方插件进程" class="headerlink" title="2.2 第三方插件进程"></a><strong>2.2 第三方插件进程</strong></h3><p>&emsp;&emsp;每种类型的插件对应一个进程，仅当使用该插件时才创建。</p><h3 id="2-3-GPU进程"><a href="#2-3-GPU进程" class="headerlink" title="2.3 GPU进程"></a><strong>2.3 GPU进程</strong></h3><p>&emsp;&emsp;只有一个，负责3D绘制，只有当该页面使用了硬件加速才会使用它，来渲染（显示）页面。否则的话，不使用这个进程，而是用Browser进程来渲染（显示）页面。</p><h3 id="2-4-浏览器渲染进程（又称浏览器内核，Renderer-进程，内部是多线程的）"><a href="#2-4-浏览器渲染进程（又称浏览器内核，Renderer-进程，内部是多线程的）" class="headerlink" title="2.4 浏览器渲染进程（又称浏览器内核，Renderer 进程，内部是多线程的）"></a><strong>2.4 浏览器渲染进程（又称浏览器内核，Renderer 进程，内部是多线程的）</strong></h3><p>&emsp;&emsp;负责脚本执行，位图绘制，事件触发，任务队列轮询等 。</p><h4 id="2-4-1-GUI-渲染线程"><a href="#2-4-1-GUI-渲染线程" class="headerlink" title="2.4.1 GUI 渲染线程"></a><strong>2.4.1 GUI 渲染线程</strong></h4><p>&emsp;&emsp;负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行<br>&emsp;&emsp;<font color="red">注：GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。为什么互斥：由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS 线程和 UI 线程同时运行)， 那么渲染线程前后获得的元素就可能不一致了（简单说就是 js 修改 dom 后没有重新渲染成功）</font></p><h4 id="2-4-2-JS-引擎线程"><a href="#2-4-2-JS-引擎线程" class="headerlink" title="2.4.2 JS 引擎线程"></a><strong>2.4.2 JS 引擎线程</strong></h4><p>&emsp;&emsp;也称为 JS 内核，负责处理 Javascript 脚本程序。JS 引擎线程负责解析 Javascript 脚本，运行代码。JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序<br>&emsp;&emsp;<font color="red">注： GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</font></p><h4 id="2-4-3-事件触发线程"><a href="#2-4-3-事件触发线程" class="headerlink" title="2.4.3 事件触发线程"></a><strong>2.4.3 事件触发线程</strong></h4><p>&emsp;&emsp;归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）。当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中，当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。<br>&emsp;&emsp;<font color="red">注：由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）。</font></p><h4 id="2-4-4-定时触发器线程"><a href="#2-4-4-定时触发器线程" class="headerlink" title="2.4.4 定时触发器线程"></a><strong>2.4.4 定时触发器线程</strong></h4><p>&emsp;&emsp;setInterval 与 setTimeout(这些 API 却不是引擎提供的而是浏览器提供的 Web API，比如说 DOM、AJAX、setTimeout) 所在线程浏览器定时计数器并不是由JavaScript 引擎计数的，因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确。因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）。<br>&emsp;&emsp;<font color="red">注：W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</font></p><h4 id="2-4-5-异步-http-请求线程"><a href="#2-4-5-异步-http-请求线程" class="headerlink" title="2.4.5 异步 http 请求线程"></a><strong>2.4.5 异步 http 请求线程</strong></h4><p>&emsp;&emsp;在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 JavaScript 引擎执行。</p><h2 id="三-浏览器的运行机制"><a href="#三-浏览器的运行机制" class="headerlink" title="三. 浏览器的运行机制"></a><strong>三. 浏览器的运行机制</strong></h2><ol><li>构建DOM树（parse）：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）<strong>生成内容树</strong>（Content Tree/DOM Tree）；</li><li>构建渲染树（construct）：解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如<b></b>）<strong>，构建渲染树</strong>（Rendering Tree/Frame Tree）；render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现</li><li>布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；</li><li>绘制渲染树（paint/repaint）：遍历渲染树，使用UI 层来绘制每个节点。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端优化 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
