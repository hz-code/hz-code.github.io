<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入理解浏览器运行机制</title>
      <link href="2021/02/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>2021/02/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一-进程和线程"><a href="#一-进程和线程" class="headerlink" title="一. 进程和线程"></a>一. 进程和线程</h2><p>​        计算机的核心是CPU，它承担了所有的计算任务。我们假设CPU是一个时刻在运行的工厂，假设工厂的电力有限（CPU的计算能力有限），一次只能供给一个车间（单个CPU一次只能运行一个任务）。</p><p>​        进程就像工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，同时其他进程处于非运行状态;</p><p>​        而线程是工厂车间中的工人，可能只有一个，也可能有很多个，他们协同完成工作。车间的空间是工人们共享的，这意味着一个进程下的线程共享该进程的内存空间。</p><hr><p><font color="red">注:<br>&emsp;&emsp; 一个软件不等于一个进程，一个软件可能包含有多个户向独立的进程；<br/><br>&emsp;&emsp;进程是系统资源分配的最小单位(即系统以进程为最小单位分配内存空间，同时进程是能独立运行的最小单位）；<br/><br>&emsp;&emsp;线程是系统调度的最小单位（即系统以进程为单位分配CPUT中的核）；<br/><br>&emsp;&emsp;进程之间也能相互通信，但代价较大。</font></p><h2 id="二-浏览器中的进程"><a href="#二-浏览器中的进程" class="headerlink" title="二. 浏览器中的进程"></a>二. 浏览器中的进程</h2><p><img src="/img/1.png" class="lazyload" data-srcset="/img/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="2-1-浏览器主进程（Browser进程）"><a href="#2-1-浏览器主进程（Browser进程）" class="headerlink" title="2.1 浏览器主进程（Browser进程）"></a><strong>2.1 浏览器主进程（Browser进程）</strong></h3><p>&emsp;&emsp;浏览器的主进程只有一个，负责协调、主控。</p><ul><li>&emsp;负责浏览器界面显示，与用户交互，如前进，后退等；</li><li>&emsp;负责各个页面的管理，创建和销毁其他进程；</li><li>&emsp;负责将渲染进程得到的内存中的 Bitmap，绘制到用户界面上；</li><li>&emsp;负责网络资源的管理，下载等。</li></ul><h3 id="2-2-第三方插件进程"><a href="#2-2-第三方插件进程" class="headerlink" title="2.2 第三方插件进程"></a><strong>2.2 第三方插件进程</strong></h3><p>&emsp;&emsp;每种类型的插件对应一个进程，仅当使用该插件时才创建。</p><h3 id="2-3-GPU进程"><a href="#2-3-GPU进程" class="headerlink" title="2.3 GPU进程"></a><strong>2.3 GPU进程</strong></h3><p>&emsp;&emsp;只有一个，负责3D绘制，只有当该页面使用了硬件加速才会使用它，来渲染（显示）页面。否则的话，不使用这个进程，而是用Browser进程来渲染（显示）页面。</p><h3 id="2-4-浏览器渲染进程（又称浏览器内核，Renderer-进程，内部是多线程的）"><a href="#2-4-浏览器渲染进程（又称浏览器内核，Renderer-进程，内部是多线程的）" class="headerlink" title="2.4 浏览器渲染进程（又称浏览器内核，Renderer 进程，内部是多线程的）"></a><strong>2.4 浏览器渲染进程（又称浏览器内核，Renderer 进程，内部是多线程的）</strong></h3><p>&emsp;&emsp;负责脚本执行，位图绘制，事件触发，任务队列轮询等 。</p><h4 id="2-4-1-GUI-渲染线程"><a href="#2-4-1-GUI-渲染线程" class="headerlink" title="2.4.1 GUI 渲染线程"></a><strong>2.4.1 GUI 渲染线程</strong></h4><p>&emsp;&emsp;负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行<br>&emsp;&emsp;<font color="red">注：GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。为什么互斥：由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS 线程和 UI 线程同时运行)， 那么渲染线程前后获得的元素就可能不一致了（简单说就是 js 修改 dom 后没有重新渲染成功）</font></p><h4 id="2-4-2-JS-引擎线程"><a href="#2-4-2-JS-引擎线程" class="headerlink" title="2.4.2 JS 引擎线程"></a><strong>2.4.2 JS 引擎线程</strong></h4><p>&emsp;&emsp;也称为 JS 内核，负责处理 Javascript 脚本程序。JS 引擎线程负责解析 Javascript 脚本，运行代码。JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序<br>&emsp;&emsp;<font color="red">注： GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</font></p><h4 id="2-4-3-事件触发线程"><a href="#2-4-3-事件触发线程" class="headerlink" title="2.4.3 事件触发线程"></a><strong>2.4.3 事件触发线程</strong></h4><p>&emsp;&emsp;归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）。当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中，当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。<br>&emsp;&emsp;<font color="red">注：由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）。</font></p><h4 id="2-4-4-定时触发器线程"><a href="#2-4-4-定时触发器线程" class="headerlink" title="2.4.4 定时触发器线程"></a><strong>2.4.4 定时触发器线程</strong></h4><p>&emsp;&emsp;setInterval 与 setTimeout(这些 API 却不是引擎提供的而是浏览器提供的 Web API，比如说 DOM、AJAX、setTimeout) 所在线程浏览器定时计数器并不是由JavaScript 引擎计数的，因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确。因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）。<br>&emsp;&emsp;<font color="red">注：W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</font></p><h4 id="2-4-5-异步-http-请求线程"><a href="#2-4-5-异步-http-请求线程" class="headerlink" title="2.4.5 异步 http 请求线程"></a><strong>2.4.5 异步 http 请求线程</strong></h4><p>&emsp;&emsp;在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 JavaScript 引擎执行。</p><h2 id="三-浏览器的运行机制"><a href="#三-浏览器的运行机制" class="headerlink" title="三. 浏览器的运行机制"></a><strong>三. 浏览器的运行机制</strong></h2><ol><li>构建DOM树（parse）：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）<strong>生成内容树</strong>（Content Tree/DOM Tree）；</li><li>构建渲染树（construct）：解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如<b></b>）<strong>，构建渲染树</strong>（Rendering Tree/Frame Tree）；render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现</li><li>布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；</li><li>绘制渲染树（paint/repaint）：遍历渲染树，使用UI 层来绘制每个节点。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端优化 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
