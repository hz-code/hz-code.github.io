{"meta":{"title":"暂未成功人士","subtitle":"","description":"","author":"Hz","url":"https://hz-code.github.io","root":"/"},"pages":[{"title":"","date":"2021-02-26T12:51:27.489Z","updated":"2021-02-26T12:51:27.489Z","comments":false,"path":"about/index.html","permalink":"https://hz-code.github.io/about/index.html","excerpt":"","text":"别辜负自己庆幸自己还没有秃头"},{"title":"所有分类","date":"2021-02-26T13:08:51.168Z","updated":"2021-02-26T13:08:51.168Z","comments":true,"path":"categories/index.html","permalink":"https://hz-code.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-02-26T13:09:14.203Z","updated":"2021-02-26T13:09:14.203Z","comments":true,"path":"tags/index.html","permalink":"https://hz-code.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-02-26T12:53:36.216Z","updated":"2021-02-26T12:53:36.216Z","comments":true,"path":"messboard/index.html","permalink":"https://hz-code.github.io/messboard/index.html","excerpt":"","text":"就随便说点什么吧"}],"posts":[{"title":"async函数学习记录","slug":"async函数学习记录","date":"2021-02-27T05:25:53.000Z","updated":"2021-02-27T09:13:56.401Z","comments":true,"path":"2021/02/27/async函数学习记录/","link":"","permalink":"https://hz-code.github.io/2021/02/27/async%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"一. Generator函数Generator函数从语法上可以理解成一个状态机，它的内部封装了多个状态。当执行Generator函数时候会返回一个遍历器对象，返回的遍历器对象可以一次遍历Generator函数内部的每一个状态。 形式上，Generator函数只是一个普通函数。 1234567function* testGenerator() &#123; yield &#x27;I am&#x27;; yield &#x27;Generator&#x27;; return &#x27;ending&#x27;;&#125;var test = testGenerator(); 它有两个特征，一是，function关键字与函数名之间有一个*号；二是，函数体内部使用yield表达式定义不同的内部状态。上述代码定义了一个Generator函数testGenerator，在它的内部有两个yield表达式，同时该函数有三个状态：I am，Generator和return语句。 调用Generator函数后，该函数不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象（也就是遍历器对象）。 调用Generator函数的下一步是必须调用遍历器的next发明方法，使得指针移向下一个状态。每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式或return语句。简单概括，Generator函数是分段执行的，yield表达式是暂停执行的标记，next方法可以恢复执行。 1234567891011test.next()// &#123; value: &#x27;I am&#x27;, done: false &#125;test.next()// &#123; value: &#x27;Generator&#x27;, done: false &#125;test.next()// &#123; value: &#x27;ending&#x27;, done: true &#125;test.next()// &#123; value: undefined, done: true &#125; 上述代码一共调用了四次next()方法。 注：yield只能用在Generator函数中；yield表达式如果用在另一个表达式之中，必须放在圆括号内 1234function* demo() &#123; console.log(&#x27;Hello&#x27; + (yield)); // OK console.log(&#x27;Hello&#x27; + (yield 123)); // OK&#125; yield表达式用作函数参数或放在赋值表达式右边，可以不加括号 1234function* demo() &#123; foo(yield &#x27;a&#x27;, yield &#x27;b&#x27;); // OK let input = yield; // OK&#125; next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值 1.1 Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 12345678910111213141516171819var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(&#x27;内部捕获&#x27;, e); &#125;&#125;;var i = g();i.next();try &#123; i.throw(&#x27;a&#x27;); i.throw(&#x27;b&#x27;);&#125; catch (e) &#123; console.log(&#x27;外部捕获&#x27;, e);&#125;// 内部捕获 a// 外部捕获 b 不要混淆遍历器对象的throw方法和全局的throw命令。throw命令抛出的错误只能被函数体外的catch语句捕获。 123456789101112131415161718192021var g = function* () &#123; while (true) &#123; try &#123; yield; &#125; catch (e) &#123; if (e != &#x27;a&#x27;) throw e; console.log(&#x27;内部捕获&#x27;, e); &#125; &#125;&#125;;var i = g();i.next();try &#123; throw new Error(&#x27;a&#x27;); throw new Error(&#x27;b&#x27;);&#125; catch (e) &#123; console.log(&#x27;外部捕获&#x27;, e);&#125;// 外部捕获 [Error: a] 如果Generator函数内部没用部署try...catch代码块，throw方法抛出的错误，将被外部try...catch代码块捕获 1234567891011121314151617var g = function* () &#123; while (true) &#123; yield; console.log(&#x27;内部捕获&#x27;, e); &#125;&#125;;var i = g();i.next();try &#123; i.throw(&#x27;a&#x27;); i.throw(&#x27;b&#x27;);&#125; catch (e) &#123; console.log(&#x27;外部捕获&#x27;, e);&#125;// 外部捕获 a 1.2 Generator.prototype.return()1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return(&#x27;foo&#x27;) // &#123; value: &quot;foo&quot;, done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 上面代码中，遍历器对象g调用return()方法后，返回值的value属性就是return()方法的参数foo。并且，Generator 函数的遍历就终止了，返回值的done属性为true，以后再调用next()方法，done属性总是返回true。 12345678910function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return() // &#123; value: undefined, done: true &#125; 如果return()方法调用时，不提供参数，则返回值的value属性为undefined。 1234567891011121314151617function* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g = numbers();g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 2, done: false &#125;g.return(7) // &#123; value: 4, done: false &#125;g.next() // &#123; value: 5, done: false &#125;g.next() // &#123; value: 7, done: true &#125; 如果 Generator 函数内部有try...finally代码块，且正在执行try代码块，那么return()方法会导致立刻进入finally代码块，执行完以后，整个函数才会结束。 上面代码中，调用return()方法后，就开始执行finally代码块，不执行try里面剩下的代码了，然后等到finally代码块执行完，再返回return()方法指定的返回值。 二. async函数async函数使得异步操作变得更加方便。简单概括async函数，它就说Generator函数的语法糖。 1234567891011121314151617const fs = require(&#x27;fs&#x27;);const readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile(&#x27;/etc/test1&#x27;); const f2 = yield readFile(&#x27;/etc/test2&#x27;); console.log(f1.toString()); console.log(f2.toString());&#125;; 上面代码的函数gen可以写成async函数，就是下面这样： 123456const asyncReadFile = async function () &#123; const f1 = await readFile(&#x27;/etc/test1&#x27;); const f2 = await readFile(&#x27;/etc/test2&#x27;); console.log(f1.toString()); console.log(f2.toString());&#125;; 通过比较发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await。 async函数对 Generator 函数的改进，体现在以下四点。 （1）内置执行器。 Generator 函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 1asyncReadFile(); 上面的代码调用了test函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，才能真正执行，得到最后结果。 （2）更好的语义。 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 （3）更广的适用性。 co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。 （4）返回值是 Promise。 async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 三. async函数的实现原理async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。 1234567891011async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function* () &#123; // ... &#125;);&#125; 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。 spawn函数的实现： 12345678910111213141516171819202122function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; const gen = genF(); function step(nextF) &#123; let next; try &#123; next = nextF(); &#125; catch(e) &#123; return reject(e); &#125; if(next.done) &#123; return resolve(next.value); &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v); &#125;); &#125;, function(e) &#123; step(function() &#123; return gen.throw(e); &#125;); &#125;); &#125; step(function() &#123; return gen.next(undefined); &#125;); &#125;);&#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"https://hz-code.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://hz-code.github.io/tags/ES6/"}]},{"title":"重绘和回流","slug":"重绘和回流","date":"2021-02-26T03:29:10.000Z","updated":"2021-02-27T09:14:59.502Z","comments":true,"path":"2021/02/26/重绘和回流/","link":"","permalink":"https://hz-code.github.io/2021/02/26/%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/","excerpt":"","text":"一. 重绘和回流的概念&emsp;&emsp;重绘（repaint）：从名字来看，重绘 = 重新绘制（绘画 + 上色） 。当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。而重绘是指一个元素外观改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。 &emsp;&emsp;触发重绘的条件：元的外观属性改变，如: color，background-color等。 &emsp;&emsp;回流（重排/重构/reflow）：取其中最容易理解的重构来说，重构 = 重新构建。当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等属性改变而需要重新构建的时候，这就称为回流。 &emsp;&emsp;每个页面至少需要一次回流，那就是在页面第一次加载的时候 &emsp;&emsp;触发回流的条件:&emsp;&emsp;1、页面渲染初始化（无法避免）；&emsp;&emsp;2、添加或删除可见的DOM元素；&emsp;&emsp;3、元素位置的改变，或者使用动画；&emsp;&emsp;4、元素尺寸的改变——大小，外边距，边框；&emsp;&emsp;5、浏览器窗口尺寸的变化（resize事件发生时）；&emsp;&emsp;6、填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；&emsp;&emsp;7、读取某些元素属性：（offsetLeft/Top/Height/Width, clientTop/Left/Width/Height, scrollTop/Left/Width/Height, width/height, getComputedStyle(), currentStyle(IE) ) 二. 重绘和回流的关系&emsp;&emsp;在回流的时候，浏览器会使渲染树中收到影响的部分失效，并重新构建这部分渲染树。完成回流后，浏览器会重新绘制所受影响的部分到页面中，该过程称为重绘。所以，回流必定引发重绘，但是重绘不一定会引发回流。 重绘回流的代价：耗时，导致浏览器卡慢!!! 三. 重绘回流操作的优化方案3.1 最小化重绘和回流&emsp;&emsp;由于重绘和回流操作的代价昂贵，因此最直接的优化方法就说减少重绘和回流的发生次数。我们可以合并对此对DOM或样式的修改，然后进行一次处理。 &emsp;&emsp;例： 1234const el = document.getElementById(&#x27;editStyle&#x27;);el.style.padding = &#x27;5px&#x27;;el.style.width = &#x27;10px&#x27;;el.style.height = &#x27;20px&#x27;; &emsp;&emsp;在上述代码中，又多个样式属性被修改，这些属性都会影响元素的几何结构变化，所以它们都会引发回流，在旧版本浏览器中上述代码会引发三次回流。为了减少回流，我们可以采取合并修改的方式: 12const el = document.getElementById(&#x27;editStyle&#x27;);el.style.cssText += &#x27;padding: 5px; width:10px; height:20px&#x27; 或者 12345.edit&#123; padding:5px; width:10px; height:20px;&#125; 12const el = document.getElementById(&#x27;editStyle&#x27;);el.className += &#x27;edit&#x27;; 3.2 通过display属性设置&emsp;&emsp;在对元素样式进行修改的时候，我们可以先设置元素的display属性为none（这是因为隐藏元素进行操作的时候是不会引起重绘和回流的），然后进行页面布局或样式修改等操作。当这些操作完成后，再将元素display属性设置为block,通过修改display属性只引发两次重绘和回流。 3.3 通过position属性设置&emsp;&emsp;将需要多次回流的元素的postion属性设置为absolute或者fixed，这样会使元素脱离文档流，这时候它的变化不会影响到其它元素。 &emsp;&emsp;注：脱离文档流指的是元素脱离正常元素的布局排版工会则，其他处于文档流中的元素再计算布局排版的时候，会自动无视已经脱离文档流的元素进行定位。 &emsp;&emsp;浮动与absolute/fixed的区别就在于，浮动会使元素脱离文档流，但不会脱离文本流，在与其他元素的文本内容计算布局的时候，还是占位置的；absolute/fixed既脱离文档流也脱离文本流。 3.4 cloneNode 和 replaceChild&emsp;&emsp;通过使用cloneNode和replaceChild技术，只引发一次重绘和回流。 cloneNode使用: 12345678910// cloneNode创建一个test节点的拷贝// cloneNode(true)时递归赋值test节点的所有子孙节点// cloneNode(false)时只赋值当前节点var node=document.getElementById(&quot;test&quot;).lastChild.cloneNode(true);// 省略了对赋值节点属性的操作......// 添加赋值的node节点作为oldNode节点的子节点document.getElementById(&quot;oldNode&quot;).appendChild(node); replaceChild使用: 12345// 省略了对newNode节点属性的操作......// 将test的子节点替换为一个新的节点document.getElementById(&quot;test&quot;).replaceChild(newnode,oldnode); 3.5 createDocumentFragment12345678910// createDocumentFragment()方法创建了一个虚拟的节点对象，节点对象包含所有的属性和方法。var d=document.createDocumentFragment();// 对创建的虚拟节点进行操作// 如果使用appendChid方法将原dom树中的节点添加到DocumentFragment中时，会删除原来的节点。 d.appendChild(document.getElementsByTagName(&quot;LI&quot;)[0]);d.childNodes[0].childNodes[0].nodeValue=&quot;Milk&quot;;// 当请求把一个DocumentFragment节点插入文档树时，插入的不是DocumentFragment自身，而是它的所有子孙节点，即插入的是括号里的节点。这个特性使得DocumentFragment成了占位符，暂时存放那些一次插入文档的节点。document.getElementsByTagName(&quot;UL&quot;)[0].appendChild(d);","categories":[{"name":"前端优化","slug":"前端优化","permalink":"https://hz-code.github.io/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"},{"name":"html/css","slug":"前端优化/html-css","permalink":"https://hz-code.github.io/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/html-css/"}],"tags":[{"name":"前端优化","slug":"前端优化","permalink":"https://hz-code.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"},{"name":"浏览器","slug":"浏览器","permalink":"https://hz-code.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"html/css","slug":"html-css","permalink":"https://hz-code.github.io/tags/html-css/"}]},{"title":"深入理解浏览器运行机制","slug":"深入理解浏览器运行机制","date":"2021-02-25T09:47:11.000Z","updated":"2021-02-27T09:15:15.098Z","comments":true,"path":"2021/02/25/深入理解浏览器运行机制/","link":"","permalink":"https://hz-code.github.io/2021/02/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/","excerpt":"","text":"一. 进程和线程​ 计算机的核心是CPU，它承担了所有的计算任务。我们假设CPU是一个时刻在运行的工厂，假设工厂的电力有限（CPU的计算能力有限），一次只能供给一个车间（单个CPU一次只能运行一个任务）。 ​ 进程就像工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，同时其他进程处于非运行状态; ​ 而线程是工厂车间中的工人，可能只有一个，也可能有很多个，他们协同完成工作。车间的空间是工人们共享的，这意味着一个进程下的线程共享该进程的内存空间。 注:&emsp;&emsp;一个软件不等于一个进程，一个软件可能包含有多个户向独立的进程；&emsp;&emsp;进程是系统资源分配的最小单位(即系统以进程为最小单位分配内存空间，同时进程是能独立运行的最小单位）；&emsp;&emsp;线程是系统调度的最小单位（即系统以进程为单位分配CPUT中的核）；&emsp;&emsp;进程之间也能相互通信，但代价较大。 二. 浏览器中的进程 2.1 浏览器主进程（Browser进程）&emsp;&emsp;浏览器的主进程只有一个，负责协调、主控。 &emsp;负责浏览器界面显示，与用户交互，如前进，后退等； &emsp;负责各个页面的管理，创建和销毁其他进程； &emsp;负责将渲染进程得到的内存中的 Bitmap，绘制到用户界面上； &emsp;负责网络资源的管理，下载等。 2.2 第三方插件进程&emsp;&emsp;每种类型的插件对应一个进程，仅当使用该插件时才创建。 2.3 GPU进程&emsp;&emsp;只有一个，负责3D绘制，只有当该页面使用了硬件加速才会使用它，来渲染（显示）页面。否则的话，不使用这个进程，而是用Browser进程来渲染（显示）页面。 2.4 浏览器渲染进程（又称浏览器内核，Renderer 进程，内部是多线程的）&emsp;&emsp;负责脚本执行，位图绘制，事件触发，任务队列轮询等 。 2.4.1 GUI 渲染线程&emsp;&emsp;负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行&emsp;&emsp;注：GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。为什么互斥：由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS 线程和 UI 线程同时运行)， 那么渲染线程前后获得的元素就可能不一致了（简单说就是 js 修改 dom 后没有重新渲染成功） 2.4.2 JS 引擎线程&emsp;&emsp;也称为 JS 内核，负责处理 Javascript 脚本程序。JS 引擎线程负责解析 Javascript 脚本，运行代码。JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序&emsp;&emsp;注： GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 2.4.3 事件触发线程&emsp;&emsp;归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）。当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中，当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。&emsp;&emsp;注：由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）。 2.4.4 定时触发器线程&emsp;&emsp;setInterval 与 setTimeout(这些 API 却不是引擎提供的而是浏览器提供的 Web API，比如说 DOM、AJAX、setTimeout) 所在线程浏览器定时计数器并不是由JavaScript 引擎计数的，因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确。因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）。&emsp;&emsp;注：W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。 2.4.5 异步 http 请求线程&emsp;&emsp;在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 JavaScript 引擎执行。 三. 浏览器的运行机制 构建DOM树（parse）：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）生成内容树（Content Tree/DOM Tree）； 构建渲染树（construct）：解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如），构建渲染树（Rendering Tree/Frame Tree）；render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现 布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标； 绘制渲染树（paint/repaint）：遍历渲染树，使用UI 层来绘制每个节点。","categories":[{"name":"前端优化","slug":"前端优化","permalink":"https://hz-code.github.io/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"前端优化","slug":"前端优化","permalink":"https://hz-code.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"},{"name":"浏览器","slug":"浏览器","permalink":"https://hz-code.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]}],"categories":[{"name":"ES6","slug":"ES6","permalink":"https://hz-code.github.io/categories/ES6/"},{"name":"前端优化","slug":"前端优化","permalink":"https://hz-code.github.io/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"},{"name":"html/css","slug":"前端优化/html-css","permalink":"https://hz-code.github.io/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/html-css/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://hz-code.github.io/tags/ES6/"},{"name":"前端优化","slug":"前端优化","permalink":"https://hz-code.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"},{"name":"浏览器","slug":"浏览器","permalink":"https://hz-code.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"html/css","slug":"html-css","permalink":"https://hz-code.github.io/tags/html-css/"}]}